# 8. hét

- operátor túlterhelés

### Komplex szám operátorai

Készíts komplex szám opsztályt az alábbi operátorokkal:
- +, -, *, / másik komplex számmal
- +=, -=, *=, /= másik komplex számmal
- == operátor másik komplex számmal
- ugyanezek a műveletek double típussal
- pre/post inkrementálás/dekrementálás (++ és --)
- << kiíráshoz

<details>
 <summary>megoldás:</summary>
 
```cpp
class Komplex{
public: // TODO
    double re, im;
    
public:
    Komplex operator+(const Komplex &masik) const {
        Komplex eredmeny;
        eredmeny.re = re+masik.re;
        eredmeny.im = im+masik.im;
        return eredmeny;
    }
    
    Komplex operator-(const Komplex &masik) const {
        Komplex eredmeny;
        eredmeny.re = re-masik.re;
        eredmeny.im = im-masik.im;
        return eredmeny;
    }
    
    Komplex operator*(const Komplex &masik) const {
        Komplex eredmeny;
        eredmeny.re = re*masik.re - im*masik.im;
        eredmeny.im = re*masik.im + im*masik.re;
        return eredmeny;
    }
    
    Komplex operator/(const Komplex &masik) const {
        Komplex eredmeny;
        eredmeny.re = (re*masik.re + im*masik.im)/(masik.re*masik.re + masik.im*masik.im);
        eredmeny.im = (im*masik.re - re*masik.im)/(masik.re*masik.re + masik.im*masik.im);
        return eredmeny;
    }
    
    Komplex operator+=(const Komplex &masik) {
        re += masik.re;
        im += masik.im;
        return *this; // ilyenkor illik a saját értéket visszaadni
    }
    
    Komplex operator-=(const Komplex &masik) {
        re -= masik.re;
        im -= masik.im;
        return *this;
    }
    
    Komplex operator*=(const Komplex &masik) {
        // itt már muszáj átmenetileg tárolni adatokat
        Komplex eredmeny;
        eredmeny.re = re*masik.re - im*masik.im;
        eredmeny.im = re*masik.im + im*masik.re;
        re = eredmeny.re;
        im = eredmeny.im;
        return *this;
    }
    
    Komplex operator/=(const Komplex &masik) {
        // itt is muszáj átmenetileg tárolni adatokat
        Komplex eredmeny;
        eredmeny.re = (re*masik.re + im*masik.im)/(masik.re*masik.re + masik.im*masik.im);
        eredmeny.im = (im*masik.re - re*masik.im)/(masik.re*masik.re + masik.im*masik.im);
        re = eredmeny.re;
        im = eredmeny.im;
        return *this;
    }
    
    bool operator==(const Komplex &masik) const {
        return (re==masik.re) && (im==masik.im);
    }
    
    Komplex operator+(double masik) const {
        Komplex eredmeny;
        eredmeny.re = re+masik;
        eredmeny.im = im;
        return eredmeny;
    }
    
    Komplex operator-(double masik) const {
        Komplex eredmeny;
        eredmeny.re = re-masik;
        eredmeny.im = im;
        return eredmeny;
    }
    
    Komplex operator*(double masik) const {
        Komplex eredmeny;
        eredmeny.re = re*masik;
        eredmeny.im = im*masik;
        return eredmeny;
    }
    
    Komplex operator/(double masik) const {
        Komplex eredmeny;
        eredmeny.re = re/masik;
        eredmeny.im = im/masik;
        return eredmeny;
    }
    
    Komplex operator+=(double masik) {
        re += masik;
        return *this; // ilyenkor illik a saját értéket visszaadni
    }
    
    Komplex operator-=(double masik) {
        re -= masik;
        return *this;
    }
    
    Komplex operator*=(double masik) {
        re *= masik;
        im *= masik;
        return *this;
    }
    
    Komplex operator/=(double masik) {
        re /= masik;
        im /= masik;
        return *this;
    }
    
    // pre increment
    Komplex operator++(){
        re++;
        return *this;
    }
    
    // post increment
    Komplex operator++(int){
        Komplex tmp = *this;
        re++;
        return tmp;
    }
    
    // pre decrement
    Komplex operator--(){
        re--;
        return *this;
    }
    
    // post decrement
    Komplex operator--(int){
        Komplex tmp = *this;
        re--;
        return tmp;
    }
};
```
</details>


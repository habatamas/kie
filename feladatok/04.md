# 4. hét

- sztringkezelés

### Sztring elejének vizsgálata

Írj függvényt, ami megvizsgálja, hogy egy sztring egy másik sztringgel kezdõdik-e.
<details>
 <summary>megoldás:</summary>
 
```cpp
bool eleje(const string &ez, const string &ezzel_kezdodik) {
	return ez.substr(0, ezzel_kezdodik.size()) == ezzel_kezdodik;
}

// másik megoldás
bool eleje2(const string &ez, const string &ezzel_kezdodik) {
	return ez.find(ezzel_kezdodik)==0;
}
```
</details>

### Elõfordulások száma

Írj függvényt, ami megszámolja, hogy egy sztringben hányszor szerepel egy másik sztring.
<details>
 <summary>megoldás:</summary>
 
```cpp
int hanyszor(const string &s, const string &keresett) {
	int honnan = 0;
	int szamlalo = 0;
	while (s.find(keresett, honnan) != -1) {
		honnan = s.find(keresett, honnan) + 1;
		szamlalo++;
	}
	return szamlalo;
}
```
</details>

### Keresés és csere

Írj függvényt, ami egy sztringben egy keresési kulcsszó összes elõfordulását kicseréli egy másik sztringre.
A függvény az eredeti sztringet módosítsa!
<details>
 <summary>megoldás:</summary>
 
```cpp
void csere(string &ebben, const string &ezt, const string &erre) {
	while (ebben.find(ezt) != -1) {
		int talalat = ebben.find(ezt);
		ebben = ebben.substr(0, talalat) + erre + ebben.substr(talalat + ezt.length());
	}
}
```
</details>

### Darabol

Írj függvényt, ami egy sztringet adott elválasztó-részsztringek mentén feldarabol.
A darabokat tegye egy dinamikusan foglalt tömbbe, aminek kezdõcímével térjen vissza.
<details>
 <summary>megoldás:</summary>
 
```cpp
string *darabol(string &str, const string &elvalaszto) {
	// helyfoglalás a sztringeknek
	int n = hanyszor(str, elvalaszto)+1;
	string *darabok = new string[n];

	// darabolás
	int honnan = 0;
	for (int i = 0; i < n; i++) {
		int talalat = str.find(elvalaszto, honnan);
		if (talalat == -1)
			talalat = str.length();
		darabok[i] = str.substr(honnan, talalat - honnan);
		honnan = talalat + elvalaszto.length();
	}

	return darabok;
}
```
</details>

### Anagramma

Írj függvényt, ami két sztringrõl eldönti, hogy anagrammák-e. Két szó anagramma, ha csak a betûk
sorrendjében különböznek.
<details>
 <summary>megoldás:</summary>
 
```cpp
bool anagramma(string s1, string s2) {
	// sztringek rendezése
	for (int meddig = s1.length() - 2; meddig >= 0; meddig--) {
		for (int i = 0; i <= meddig; i++) {
			if (s1[i] > s1[i + 1]) {
				char tmp = s1[i];
				s1[i] = s1[i + 1];
				s1[i + 1] = tmp;
			}
		}
	}
	for (int meddig = s2.length() - 2; meddig >= 0; meddig--) {
		for (int i = 0; i <= meddig; i++) {
			if (s2[i] > s2[i + 1]) {
				char tmp = s2[i];
				s2[i] = s2[i + 1];
				s2[i + 1] = tmp;
			}
		}
	}

	// akkor anagrammák, ha rendezve megegyeznek
	return s1 == s2;
}
```
</details>

### Összefûzõ

Írj függvényt, ami egy sztringekbõl álló tömb elemeit összefûzi úgy, hogy közéjük egy megadott elválasztó
sztringet tesz.
<details>
 <summary>megoldás:</summary>
 
```cpp
string osszefuz(string *sztringek, int db, const string &elv) {
	string eredmeny = "";
	for (int i = 0; i < db - 1; i++) {
		eredmeny += sztringek[i] + elv;
	}
	eredmeny += sztringek[db - 1];
	return eredmeny;
}
```
</details>

### Dátum

Készíts osztályt, ami egy dátumot tárol.
- legyen év, hónap és nap adattagja 
- legyen konstruktora, ami sztringet képes értelmezni, pl: "2018.01.27."
- legyen kiíró függvénye, ami ugyanilyen formában kiírja a dátumot
<details>
 <summary>megoldás:</summary>
 
```cpp
class Datum {
private:
	int ev, honap, nap;
public:
	Datum(const string &datum_str) {
		int elso_pont = datum_str.find(".");
		int masodik_pont = datum_str.find(".", elso_pont + 1);
		ev = stoi(datum_str.substr(0, elso_pont));
		honap = stoi(datum_str.substr(elso_pont+1, masodik_pont));
		nap = stoi(datum_str.substr(masodik_pont+1));
	}

	void kiir() const {
		cout << ev << "." << honap << "." << nap << "." << endl;
	}
};
```
</details>

### Caesar-kód

Írj egy függvényt, ami egy sztringet caesar-kódol.
A függvény argumentumban kapja meg, hogy hány betûvel kell elforgatni az ábécét.
A függvény csak a kis- és nagybetûket kódolja, a többi karakter maradjon változatlan!
A függvény az eredeti sztringet módosítsa, nem kell külön célsztringbe másolni!
A függvény értelmezze a pozitív és negatív elforgatást, bármekkora számokkal.

<details>
 <summary>megoldás:</summary>
 
```cpp
void caesar(string &str, int n) {
	// a forgatást normalizáljuk, hogy -25...+25 tartományban legyen
	n = n % ('z' - 'a' + 1);

	// a negatív forgatást pozitívval helyettesítjük, pl -1 -> +25
	if (n < 0)
		n += 'z' - 'a' + 1;

	// karakterenként kódolunk
	for (int i = 0; i < str.length(); i++) {

		// itt tároljuk a kódolt karaktert
		int ch = str[i] + n; // azért int, mert a char túl szûk értelmezési tartományú

		// kisbetû kódolása
		if ('a' <= str[i] && str[i] <= 'z') {
			if (ch > 'z')
				ch -= 'z' - 'a' + 1;
			str[i] = ch;
		}
		// nagybetû kódolása
		if ('A' <= str[i] && str[i] <= 'Z') {
			if (ch > 'Z')
				ch -= 'Z' - 'A' + 1;
			str[i] = ch;
		}
	}
}
```
</details>